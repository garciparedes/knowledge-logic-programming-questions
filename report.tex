\documentclass[11pt, a4paper,spanish]{article}

\usepackage[T1]{fontenc}
\usepackage[hmarginratio=1:1,top=26mm]{geometry}


\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{dirtytalk}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[C]{ \today \ $\bullet$ Ingeniería del Conocimiento $\bullet$ Tutoría sobre Programación Lógica}
\fancyfoot[RO]{\thepage}

%-------------------------------------------------------------------------------
%	TITLE SECTION
%-------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24.88pt}{10pt}\textbf{Tutoría sobre Programación Lógica}} % Article title

\author{Sergio García Prado}
\date{\today}

%-------------------------------------------------------------------------------

\begin{document}

	\maketitle % Insert title

	\thispagestyle{fancy} % All pages have headers and footers

%-------------------------------------------------------------------------------
%	TEXT
%-------------------------------------------------------------------------------

	\section{Sea $P$ el programa normal: \\
		$\{animal(snoopy) \gets, \\
		animal(kitty) \gets, \\
		gatito(kitty) \gets, \\
		gusta(elena,x) \gets animal(x), \neg gatito(x)\}\\$
		y $G$ la meta: \\
		$\gets \neg gusta(elena,kitty)$\\
		?`Cuál es la respuesta computada de $P \cup {G}$ ?}

		\paragraph{}
		Para resolver este programa normal y poder llegar a la cláusula vacía deberemos hacer uso de la Suposición de Mundo Cerrado y además de la estrategia de resolución SLD con negación por fallo.

		\paragraph{}
		Puesto que no hay ninguna regla o hecho que unifique con la meta (puesto que está negada) trataremos encontrar una que unifique con su opuesto. En el caso de poder llegar a la cláusula vacía diremos que la meta es falsa, pero si llegamos al punto en que no se puede continuar por ninguna de las ramas de cómputo y tampoco tenemos la cláusula vacía diremos que la meta era verdadera:

		\includegraphics[width=0.9\textwidth]{sldnf-computation-1}

		\paragraph{}
		Puesto que en este punto nos encontramos en la misma situación que en el paso anterior pero con una submeta realizaremos el mismo proceso considerando los mismos resultados:

		\includegraphics[width=0.9\textwidth]{sldnf-computation-2}

		\paragraph{}
		En este caso la respuesta computada ha sido la cláusula vacía por lo que la submeta es cierta, por lo que su negación falsa. Esto se propaga hacia el paso anterior, que como hace falso la submeta $gusta(elena,kitty)$ entonces su negación $ \neg gusta(elena,kitty)$ es cierta y la respuesta computada es $\theta = [ ]$.

	\section{Elaborar un programa definido que junto a la meta $G$: $\gets p(x,y)$ tenga como respuestas correctas $\{ a / x \}$ y $\{b / y\}$ pero no $\{c / x, d / y\}$, con la restricción de que el símbolo de predicado p no ocurra en ningún hecho.}

		\paragraph{}
		Conjunto de hechos y reglas:
		\[ f(a) \gets, \]
		\[ f(b) \gets, \]
		\[ p(x,y) \gets f(x), f(y) \]

		\paragraph{}
		Puesto que estamos elaborando un programa definido, que por definición es un  \say{conjunto de hechos y reglas que describen explícitamente qué es cierto, sin información explicita sobre qué es falso}, no tenemos que indicar nada sobre las constantes $c$ y $d$.

	\clearpage
	\section{Sea $P$ el programa definido: \\
		$\{entero(0) \gets ,\\
		entero(x) \gets entero(y), =(x, +(y,1))\}\\$
		y $G$ la meta: \\
		$\gets entero(2)$\\
		Obtener las tres secuencias de un cómputo de G por P que obtenga la meta vacía.}

		\paragraph{}
		Para obtener la meta vacía se llevará a cabo una resolución SLD con la selección del primer literal de la cláusula como regla de cómputo y busqueda primero en profundidad como regla de búsqueda. El cómputo por tanto queda de la siguiente manera. Las secuencias de cómputo son:
		\begin{itemize}
			\item Metas: $G_0, G_1, G_2,G_3$
			\item Cláusulas: $C_1, C_2,C_3$
			\item UMG's $\theta_1, \theta_2, \theta_3$
		\end{itemize}
		\includegraphics[width=0.9\textwidth]{sld-computation}

\end{document}
